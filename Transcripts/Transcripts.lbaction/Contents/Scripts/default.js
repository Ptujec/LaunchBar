/* 
YouTube Transcript Action for LaunchBar
by Christian Bender (@ptujec)
2026-01-02

Copyright see: https://github.com/Ptujec/LaunchBar/blob/master/LICENSE

Documentation:
- API: https://rapidapi.com/nikzeferis/api/youtube-captions-transcript-subtitles-video-combiner/playground/apiendpoint_dccbec3e-efe7-4016-ba37-3f5e45b49999
- Example YouTube URLs:
  - https://www.youtube.com/watch?v=yiHf8klCCc4

TODO: 
- Batch option (supported by API) ?
*/

// MARK: - Configuration

const downloadsPath = Action.preferences.downloadsPath || '/tmp';
const logFile = '/tmp/youtube_transcript_debug.log';
const apiToken = Action.preferences.apiToken;
const formatOptions = {
  plain: 'Text Only',
  short: 'Text With Time Markers',
  full: 'Text With Linked Time Markers',
  srt: 'SubRip Text (SRT)',
  json: 'Raw (JSON)',
};

// MARK: - Run

function run(argument) {
  let url;
  let title;
  let source;

  if (LaunchBar.options.alternateKey) return settings();
  if (LaunchBar.options.shiftKey) return []; // Do nothing on Shift key

  if (argument) {
    if (!argument.toLowerCase().includes('youtu')) {
      return {
        title: 'Not a YouTube URL',
        icon: 'alert',
      };
    }

    url = argument;
  } else {
    const browser = LaunchBar.execute('/bin/bash', './appInfo.sh').trim();

    if (!browser) {
      return {
        title: 'No supported browser found',
        icon: 'alert',
      };
    }

    const info = getBrowserInfo(browser);

    if (!info) {
      return {
        title: `Error getting browser information from ${browser}`,
        icon: 'alert',
      };
    }

    url = info.url;
    title = info.title;
    source = browser === 'com.apple.Safari' ? info.source : null;
  }

  const videoId = extractVideoId(url);

  if (!videoId) {
    return {
      title: 'Invalid YouTube URL',
      subtitle: url,
      alwaysShowsSubtitle: true,
      icon: 'alert',
    };
  }

  return getVideoTranscript(videoId, { url, title, source });
}

// MARK: - URL Handling

function extractVideoId(url) {
  const patterns = [
    /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]+)/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?(?:[^&]*&)*v=([a-zA-Z0-9_-]+)/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) return match[1];
  }

  writeDebugLog('No video ID found in URL', 'URL Parsing Error');
  return;
}

// MARK: - Get Transcript

function getVideoTranscript(videoId, info) {
  const options = {
    method: 'GET',
    headerFields: {
      'User-Agent':
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)',
      Accept: '*/*',
    },
  };

  const result = getCaptionTracks(videoId, info.source, options);
  if (!result) {
    return {
      title: 'No transcripts available',
      icon: 'alert',
    };
  }

  let { tracks, videoTitle } = result;
  tracks = filterAutoGeneratedTracks(tracks);

  if (tracks.length === 0) {
    return {
      title: 'No transcripts available',
      icon: 'alert',
    };
  }

  return tracks.map((track) => ({
    title: track.name?.simpleText,
    subtitle: info?.title,
    icon: 'iconTemplate',
    action: 'downloadTranscript',
    actionArgument: {
      title: info?.title || videoTitle,
      videoId: videoId,
      track: track,
    },
    // actionRunsInBackground: true,
  }));
}

function filterAutoGeneratedTracks(tracks) {
  // Get language codes that have manual (non-asr) versions
  const manualLanguages = new Set(
    tracks.filter((track) => !track.kind).map((track) => track.languageCode)
  );

  // Filter out autogenerated tracks only if a manual version exists for that language
  return tracks.filter((track) => {
    if (track.kind === 'asr' && manualLanguages.has(track.languageCode)) {
      return false;
    }
    return true;
  });
}

function getCaptionTracks(videoId, pageSource, options) {
  const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
  writeDebugLog(watchUrl, 'Requesting watch URL');

  let pageData;
  if (pageSource) {
    pageData = pageSource;
    writeDebugLog('Using Safari page source', 'Source Info');
  } else {
    pageData = tracksLoadRequest(watchUrl, options);
  }

  let tracksMatch = pageData.match(
    /{"captionTracks":(\[.*?\])(?=,\s*"audioTracks")/
  );

  // Fallback
  if (!tracksMatch?.[1] && pageSource) {
    pageData = tracksLoadRequest(watchUrl, options);
    tracksMatch = pageData.match(
      /{"captionTracks":(\[.*?\])(?=,\s*"audioTracks")/
    );
  }

  if (!tracksMatch?.[1]) return null;

  let tracks;
  try {
    tracks = JSON.parse(tracksMatch[1]);
    // writeDebugLog(tracks, 'Parsed caption tracks');

    return {
      tracks,
      videoTitle: pageData
        .match(
          /"videoDetails":\s*{\s*"videoId":[^}]*"lengthSeconds":"[^"]*"/
        )?.[0]
        ?.match(/"title":"([^"]+)"/)?.[1],
    };
  } catch (e) {
    writeDebugLog(e, 'Error parsing caption tracks');
    return null;
  }
}

function tracksLoadRequest(watchUrl, options) {
  const watchResponse = HTTP.loadRequest(watchUrl, options);
  if (!watchResponse?.data) return null;
  pageData = watchResponse.data;

  writeDebugLog('Using Load Request', 'Source Info');
  return pageData;
}

function downloadTranscript(
  { title, videoId, track },
  format = Action.preferences.format || 'plain'
) {
  /*
  Example track object:
  "baseUrl": "https://www.youtube.com/api/timedtext?…",
  "name": {
    "simpleText": "Englisch (automatisch erzeugt)"
    },
    "vssId": "a.en",
    "languageCode": "en",
    "kind": "asr",
    "isTranslatable": true,
    "trackName": ""
  
  NOTE: The API may not differentiate between manually created and auto-generated captions.
  */

  if (!apiToken) return setApiKey();

  if (LaunchBar.options.commandKey) {
    return showFormatOptions(false, { title, videoId, track });
  }

  LaunchBar.hide();

  let data;

  const jsonFilename = `${downloadsPath}/${videoId}_${track.languageCode}.json`;

  if (!File.exists(jsonFilename)) {
    writeDebugLog(
      'For this transcript there is no existing JSON data',
      'Checking for existing JSON data'
    );

    data = HTTP.getJSON(
      `https://youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com/download-json/${videoId}?language=${track.languageCode}`,
      {
        headerFields: {
          'x-rapidapi-key': apiToken,
          'x-rapidapi-host':
            'youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com',
        },
      }
    );

    // File.writeJSON(data, `${Action.supportPath}/test.json`);
    // data = File.readJSON(`${Action.supportPath}/test.json`);

    File.writeJSON(data, jsonFilename);
  } else {
    writeDebugLog(
      `Using existing JSON data at ${jsonFilename}`,
      'Checking for existing JSON data'
    );
    data = File.readJSON(jsonFilename);
  }

  if (format === 'json') {
    LaunchBar.openURL(File.fileURLForPath(jsonFilename));
    return [];
  }

  if (data.response.status !== 200) {
    LaunchBar.alert(
      `Error fetching transcript (${data?.response?.status})`,
      data?.response?.localizedStatus || 'Unknown error'
    );
    return;
  }

  const name = `${title} (${track.name.simpleText})`;
  const filename = `${downloadsPath}/${name}${
    format === 'srt' ? '.srt' : '.md'
  }`;

  const transcriptData = data.data;
  const formattedTranscript = formatTranscriptData(
    transcriptData,
    videoId,
    name,
    format
  );

  File.writeText(formattedTranscript, filename);

  LaunchBar.openURL(File.fileURLForPath(filename));
}

function formatTranscriptData(transcriptData, videoId, name, format) {
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const header = `# ${name}\n\nSource: ${videoUrl}\n\n`;

  const formatTimestamp = (start) => {
    const minutes = Math.floor(start / 60);
    const seconds = Math.floor(start % 60)
      .toString()
      .padStart(2, '0');
    return `${minutes}:${seconds}`;
  };

  const formatEntry = (entry, includeLink = false) => {
    const time = formatTimestamp(entry.start);
    const text = entry.text.split('\n').join(' ');
    if (includeLink) {
      return `[${time}](${videoUrl}&t=${entry.start.split('.')[0]}s) ${text}`;
    }
    return `[${time}] ${text}`;
  };

  if (format === 'plain') {
    return (
      header +
      transcriptData
        .map((entry) => entry.text)
        .join(' ')
        .split('\n')
        .join(' ')
        .decodeHTMLEntities()
        .trim()
    );
  }

  if (format === 'short') {
    return (
      header +
      transcriptData
        .map((entry) => formatEntry(entry))
        .join('\n\n')
        .decodeHTMLEntities()
        .trim()
    );
  }

  if (format === 'full') {
    return (
      header +
      transcriptData
        .map((entry) => formatEntry(entry, true))
        .join('\n\n')
        .decodeHTMLEntities()
        .trim()
    );
  }

  if (format === 'srt') {
    const formatSRTTime = (s) => {
      const t = Math.floor(parseFloat(s));
      const h = String(Math.floor(t / 3600)).padStart(2, '0');
      const m = String(Math.floor((t % 3600) / 60)).padStart(2, '0');
      const sec = String(t % 60).padStart(2, '0');
      const ms = String(Math.round((parseFloat(s) % 1) * 1000)).padStart(
        3,
        '0'
      );
      return `${h}:${m}:${sec},${ms}`;
    };

    return transcriptData
      .map((entry, i) => {
        const start = formatSRTTime(entry.start);
        const end = formatSRTTime(
          (parseFloat(entry.start) + parseFloat(entry.dur)).toString()
        );
        const text = entry.text.decodeHTMLEntities();
        return `${i + 1}\n${start} --> ${end}\n${text}`;
      })
      .join('\n\n');
  }
}

// MARK: - Browser Handling

function getBrowserInfo(browser) {
  writeDebugLog(browser, 'Browser Info');

  let script;
  if (browser === 'com.apple.Safari') {
    script = `
      tell application id "${browser}"
        set _url to URL of front document
        set _name to name of front document
        set _source to source of front document
        return _url & "\n" & _name & "\n" & _source
      end tell
    `;
  } else {
    script = `
      tell application id "${browser}"
        set _url to URL of active tab of front window
        set _name to title of active tab of front window
        return _url & "\n" & _name
      end tell
    `;
  }

  const result = LaunchBar.executeAppleScript(script);

  if (!result.trim()) return;

  const parts = result.split('\n');
  const url = parts[0].trim();
  const title = cleanTitle(parts[1].trim());
  const source =
    browser === 'com.apple.Safari' ? parts.slice(2).join('\n') : null;

  return {
    url,
    title,
    source,
  };
}

function cleanTitle(title) {
  return title
    .replace(/^\(\d+\)\s*/, '') // Remove YouTube notification count at start
    .replace(/\//g, '') // Remove slashes
    .replace(/\s*-\s*YouTube$/, '') // Remove " - YouTube" at end
    .trim();
}

// MARK: - Settings

function settings() {
  const currentOption = Action.preferences.format || 'plain';
  const downloadsPath = Action.preferences.downloadsPath || '/tmp';

  return [
    {
      title: 'Format',
      badge: formatOptions[currentOption],
      icon: 'formatTemplate',
      action: 'showFormatOptions',
      actionReturnsItems: true,
    },
    {
      title: 'Choose Download Location',
      badge: downloadsPath,
      icon: 'folderTemplate',
      action: 'chooseDirectory',
    },
    {
      title: 'Set API-Token',
      icon: 'keyTemplate',
      action: 'setApiKey',
    },
  ];
}

function showFormatOptions(setDefault = true, info = {}) {
  const currentFormat = Action.preferences.format || 'plain';

  return Object.keys(formatOptions).map((format) => ({
    title: formatOptions[format],
    icon: format === currentFormat ? 'checkTemplate' : 'circleTemplate',
    badge: format === currentFormat ? 'default' : undefined,
    action: 'setFormat',
    actionArgument: { format, setDefault, info },
  }));
}

function setFormat({ format, setDefault, info }) {
  if (setDefault) {
    Action.preferences.format = format;
    return settings();
  }
  downloadTranscript(info, format);
}

function chooseDirectory() {
  LaunchBar.hide();

  const path = LaunchBar.executeAppleScript(
    `
    tell application "System Events" 
      activate
      set theFolder to choose folder with prompt "Choose a directory in which transcripts and logs should be stored" default location "${downloadsPath}"
      return POSIX path of theFolder
    end tell
    `
  )?.trim();

  if (!path) return settings();

  Action.preferences.downloadsPath = path;
  return settings();
}

function setApiKey() {
  const response = LaunchBar.alert(
    'API-Token required',
    '1) Open the API provider website and copy the API key.\n2) Press »Set API-Token«',
    'Open Website',
    'Set API-Token',
    'Cancel'
  );
  switch (response) {
    case 0:
      LaunchBar.openURL(
        'https://rapidapi.com/nikzeferis/api/youtube-captions-transcript-subtitles-video-combiner'
      );
      LaunchBar.hide();
      break;
    case 1:
      const clipboardContent = LaunchBar.getClipboardString().trim();

      if (clipboardContent.length == 50) {
        // TODO: Test API-Token

        // Write new API-Token in Action preferences
        Action.preferences.apiToken = clipboardContent;

        LaunchBar.alert(
          'Success!',
          `API-Token set to: ${Action.preferences.apiToken}.`
        );

        break;
      }

      LaunchBar.alert(
        'The length of the clipboard content does not match the length of a correct API-Token',
        'Make sure the API-Token is the most recent item in the clipboard!'
      );
      break;

    case 2:
      break;
  }
}

// MARK: - Debug Logging

function writeDebugLog(data, label = '') {
  // DEBUG: uncomment for debugging
  const timestamp = new Date().toISOString();
  const entry = `\n[${timestamp}] ${label}\n${JSON.stringify(data, null, 2)}\n`;
  const existingContent = File.exists(logFile) ? File.readText(logFile) : '';
  File.writeText(existingContent + entry, logFile);
}
