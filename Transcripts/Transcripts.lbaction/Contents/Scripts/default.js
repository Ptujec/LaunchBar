/* 
YouTube Transcript Action for LaunchBar
by Christian Bender (@ptujec)
2026-01-02

Copyright see: https://github.com/Ptujec/LaunchBar/blob/master/LICENSE

Documentation:
- API: https://rapidapi.com/nikzeferis/api/youtube-captions-transcript-subtitles-video-combiner/playground/apiendpoint_dccbec3e-efe7-4016-ba37-3f5e45b49999
- Example YouTube URLs:
  - https://www.youtube.com/watch?v=yiHf8klCCc4

TODO: 
- Batch option (supported by API) ?
- More options e.g. proper srt, json
- cleanup (e.g. debug logs)
- setting icons (key, format)
- update README
*/

// MARK: - Configuration

const downloadsPath = '/tmp';
const logFile = '/tmp/youtube_transcript_debug.log';
const apiToken = Action.preferences.apiToken;
const options = {
  full: 'Include Time Markers With Links',
  short: 'Include Time Markers',
  plain: 'Text Only',
};

// MARK: - Run

function run(argument) {
  let url;
  let title;
  let source;

  if (LaunchBar.options.alternateKey) return settings();
  if (LaunchBar.options.shiftKey) return []; // Do nothing on Shift key

  if (argument) {
    if (!argument.toLowerCase().includes('youtu')) {
      return {
        title: 'Not a YouTube URL',
        icon: 'alert',
      };
    }

    url = argument;
  } else {
    const browser = LaunchBar.execute('/bin/bash', './appInfo.sh').trim();

    if (!browser) {
      return {
        title: 'No supported browser found',
        icon: 'alert',
      };
    }

    const info = getBrowserInfo(browser);

    if (!info) {
      return {
        title: `Error getting browser information from ${browser}`,
        icon: 'alert',
      };
    }

    url = info.url;
    title = info.title;
    source = browser === 'com.apple.Safari' ? info.source : null;
  }

  const videoId = extractVideoId(url);

  if (!videoId) {
    return {
      title: 'Invalid YouTube URL',
      icon: 'alert',
    };
  }

  return getVideoTranscript(videoId, { url, title, source });
}

// MARK: - URL Handling

function extractVideoId(url) {
  const patterns = [
    /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]+)/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?(?:[^&]*&)*v=([a-zA-Z0-9_-]+)/,
    /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) return match[1];
  }

  writeDebugLog('No video ID found in URL', 'URL Parsing Error');
  return;
}

// MARK: - Get Transcript

function getVideoTranscript(videoId, info) {
  const options = {
    method: 'GET',
    headerFields: {
      'User-Agent':
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)',
      Accept: '*/*',
    },
  };

  const result = getCaptionTracks(videoId, info.source, options);
  if (!result) {
    return {
      title: 'No transcripts available',
      icon: 'alert',
    };
  }

  let { tracks, videoTitle } = result;
  tracks = filterAutoGeneratedTracks(tracks);

  if (tracks.length === 0) {
    return {
      title: 'No transcripts available',
      icon: 'alert',
    };
  }

  return tracks.map((track) => ({
    title: track.name?.simpleText,
    icon: 'iconTemplate',
    action: 'downloadTranscript',
    actionArgument: {
      title: info?.title || videoTitle,
      url: info?.url,
      videoId: videoId,
      track: track,
    },
    actionRunsInBackground: true,
  }));
}

function filterAutoGeneratedTracks(tracks) {
  // Get language codes that have manual (non-asr) versions
  const manualLanguages = new Set(
    tracks.filter((track) => !track.kind).map((track) => track.languageCode)
  );

  // Filter out autogenerated tracks only if a manual version exists for that language
  return tracks.filter((track) => {
    if (track.kind === 'asr' && manualLanguages.has(track.languageCode)) {
      return false;
    }
    return true;
  });
}

function getCaptionTracks(videoId, pageSource, options) {
  const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
  writeDebugLog(watchUrl, 'Requesting watch URL');

  let pageData;
  if (pageSource) {
    pageData = pageSource;
    writeDebugLog('Using Safari page source', 'Source Info');
  } else {
    const watchResponse = HTTP.loadRequest(watchUrl, options);
    if (!watchResponse?.data) return null;
    pageData = watchResponse.data;
  }

  const tracksMatch = pageData.match(
    /{"captionTracks":(\[.*?\])(?=,\s*"audioTracks")/
  );
  if (!tracksMatch?.[1]) return null;

  let tracks;
  try {
    tracks = JSON.parse(tracksMatch[1]);
    // writeDebugLog(tracks, 'Parsed caption tracks');

    return {
      tracks,
      videoTitle: pageData
        .match(
          /"videoDetails":\s*{\s*"videoId":[^}]*"lengthSeconds":"[^"]*"/
        )?.[0]
        ?.match(/"title":"([^"]+)"/)?.[1],
    };
  } catch (e) {
    writeDebugLog(e, 'Error parsing caption tracks');
    return null;
  }
}

function downloadTranscript({ title, url, videoId, track }) {
  /*
  Example track object:
  "baseUrl": "https://www.youtube.com/api/timedtext?…",
  "name": {
    "simpleText": "Englisch (automatisch erzeugt)"
    },
    "vssId": "a.en",
    "languageCode": "en",
    "kind": "asr",
    "isTranslatable": true,
    "trackName": ""
  
  NOTE: The API may not differentiate between manually created and auto-generated captions.
  */

  // TODO: Implement with API

  if (!apiToken) return setApiKey();

  LaunchBar.hide();

  let data;

  const jsonFilename = `${downloadsPath}/${videoId}_${track.languageCode}.json`;

  if (!File.exists(jsonFilename)) {
    writeDebugLog(
      'For this transcript there is no existing JSON data',
      'Checking for existing JSON data'
    );

    data = HTTP.getJSON(
      `https://youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com/download-json/${videoId}?language=${track.languageCode}`,
      {
        headerFields: {
          'x-rapidapi-key': apiToken,
          'x-rapidapi-host':
            'youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com',
        },
      }
    );

    // File.writeJSON(data, `${Action.supportPath}/test.json`);
    // data = File.readJSON(`${Action.supportPath}/test.json`);

    File.writeJSON(data, jsonFilename);
  } else {
    writeDebugLog(
      `Using existing JSON data at ${jsonFilename}`,
      'Checking for existing JSON data'
    );
    data = File.readJSON(jsonFilename);
  }

  if (data.response.status !== 200) {
    LaunchBar.alert(
      `Error fetching transcript (${data?.response?.status})`,
      data?.response?.localizedStatus || 'Unknown error'
    );
    return;
  }

  const name = `${title} (${track.name.simpleText})`;
  const filename = `${downloadsPath}/${name}.md`;

  const transcriptData = data.data;
  const formattedTranscript = formatTranscriptData(
    transcriptData,
    videoId,
    name
  );

  File.writeText(formattedTranscript, filename);

  LaunchBar.openURL(File.fileURLForPath(filename));
}

function formatTranscriptData(transcriptData, videoId, name) {
  const format = Action.preferences.format || 'short';
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const header = `# ${name}\n\nSource: ${videoUrl}\n\n`;

  const formatTimestamp = (start) => {
    const minutes = Math.floor(start / 60);
    const seconds = Math.floor(start % 60)
      .toString()
      .padStart(2, '0');
    return `${minutes}:${seconds}`;
  };

  const formatEntry = (entry, includeLink = false) => {
    const time = formatTimestamp(entry.start);
    const text = entry.text.split('\n').join(' ');
    if (includeLink) {
      return `[${time}](${videoUrl}&t=${entry.start.split('.')[0]}s) ${text}`;
    }
    return `[${time}] ${text}`;
  };

  if (format === 'plain') {
    return (
      header +
      transcriptData
        .map((entry) => entry.text)
        .join(' ')
        .split('\n')
        .join(' ')
        .decodeHTMLEntities()
        .trim()
    );
  }

  if (format === 'short') {
    return (
      header +
      transcriptData
        .map((entry) => formatEntry(entry))
        .join('\n\n')
        .decodeHTMLEntities()
        .trim()
    );
  }

  if (format === 'full') {
    return (
      header +
      transcriptData
        .map((entry) => formatEntry(entry, true))
        .join('\n\n')
        .decodeHTMLEntities()
        .trim()
    );
  }
}

// MARK: - Browser Handling

function getBrowserInfo(browser) {
  let script;
  if (browser === 'com.apple.Safari') {
    script = `
      tell application id "${browser}"
        set _url to URL of front document
        set _name to name of front document
        set _source to source of front document
        return _url & "\n" & _name & "\n" & _source
      end tell
    `;
  } else {
    script = `
      tell application id "${browser}"
        set _url to URL of active tab of front window
        set _name to title of active tab of front window
        return _url & "\n" & _name
      end tell
    `;
  }

  const result = LaunchBar.executeAppleScript(script);

  if (!result.trim()) return;

  const parts = result.split('\n');
  const url = parts[0].trim();
  const title = cleanTitle(parts[1].trim());
  const source =
    browser === 'com.apple.Safari' ? parts.slice(2).join('\n') : null;

  return {
    url,
    title,
    source,
  };
}

function cleanTitle(title) {
  return title
    .replace(/^\(\d+\)\s*/, '') // Remove YouTube notification count at start
    .replace(/\//g, '') // Remove slashes
    .replace(/\s*-\s*YouTube$/, '') // Remove " - YouTube" at end
    .trim();
}

// MARK: - Settings

function settings() {
  const currentOption = Action.preferences.format || 'short';

  return [
    {
      title: 'Format',
      badge: options[currentOption],
      icon: 'symbol:textformat',
      action: 'showFormatSettings',
      actionReturnsItems: true,
    },
    {
      title: 'Reset API-Token',
      icon: 'symbol:key.fill',
      action: 'setApiKey',
    },
  ];
}

function showFormatSettings() {
  const currentOption = Action.preferences.format || 'short';

  return Object.keys(options).map((option) => ({
    title: options[option],
    icon: option === currentOption ? 'checkTemplate' : 'circleTemplate',
    badge: option === currentOption ? 'selected' : undefined,
    action: 'setOption',
    actionArgument: option,
  }));
}

function setOption(option) {
  Action.preferences.format = option;
  return settings();
}

function setApiKey() {
  const response = LaunchBar.alert(
    'API-Token required',
    '1) Open the API provider website and copy the API key.\n2) Press »Set API-Token«',
    'Open Website',
    'Set API-Token',
    'Cancel'
  );
  switch (response) {
    case 0:
      LaunchBar.openURL(
        'https://rapidapi.com/nikzeferis/api/youtube-captions-transcript-subtitles-video-combiner'
      );
      LaunchBar.hide();
      break;
    case 1:
      const clipboardContent = LaunchBar.getClipboardString().trim();

      if (clipboardContent.length == 50) {
        // TODO: Test API-Token

        // Write new API-Token in Action preferences
        Action.preferences.apiToken = clipboardContent;

        LaunchBar.alert(
          'Success!',
          `API-Token set to: ${Action.preferences.apiToken}.`
        );

        break;
      }

      LaunchBar.alert(
        'The length of the clipboard content does not match the length of a correct API-Token',
        'Make sure the API-Token is the most recent item in the clipboard!'
      );
      break;

    case 2:
      break;
  }
}

// MARK: - Debug Logging

function writeDebugLog(data, label = '') {
  // DEBUG: uncomment for debugging
  const timestamp = new Date().toISOString();
  const entry = `\n[${timestamp}] ${label}\n${JSON.stringify(data, null, 2)}\n`;
  const existingContent = File.exists(logFile) ? File.readText(logFile) : '';
  File.writeText(existingContent + entry, logFile);
}
